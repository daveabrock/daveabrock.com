I"ÿ=<p class="notice--success">This is the full interview from my discussion with Isaac Abraham in my weekly (free!) newsletter, <em>The .NET Stacks</em>. Consider <a href="https://dotnetstacks.com">subscribing today</a>!</p>

<p>As much as we all love C#, there‚Äôs something that needs reminding from time to time: C# is <em>not</em> .NET. It is a large and important part of .NET, for sure, but .NET also supports two other languages: Visual Basic and F#. As for F#, it‚Äôs been gaining quite a bit of popularity over the last several years, and for good reason: it‚Äôs approachable, concise, and allows you to embrace a functional-first language while leveraging the power of the .NET ecosystem.</p>

<p>I caught up with Isaac Abraham to learn more about F#. After spending a decade as a C# developer, Isaac embraced the power of F# and founded <a href="https://www.compositional-it.com/">Compositional IT</a>, a functional-first consultancy. He‚Äôs also the author of <a href="https://www.manning.com/books/get-programming-with-f-sharp"><em>Get Programming with F#: A Guide for .NET Developers</em></a>.</p>

<p><img src="http://localhost:4001/images/isaac-abraham.png" alt="Isaac Abraham" /></p>

<h2 id="can-you-walk-us-through-your-career-what-youre-doing-now-and-how-you-landed-on-f">Can you walk us through your career, what you‚Äôre doing now, and how you landed on F#?</h2>

<p>I scraped into university having nearly flunked my senior school exams and took a degree in Computer Systems‚Äîit was a very practical software development degree, but there was basically minimal computer science. To this day, I don‚Äôt know how things like Big O notation works or how to implement a red-black tree‚Äîand I‚Äôm pretty woeful at maths.</p>

<p>I spent over 10 years as a C#/SQL enterprise-y developer after graduating, which was just when .NET 1.0 was launching. I went through the whole C#/OO developer journey‚Äîreading up on things like SOLID, doing the whole TDD thing religiously, and using IoC containers. It‚Äôs funny: until I learned about design patterns I had no real idea of how to ‚Äúapply‚Äù OO in a coherent sense, which looking back is remarkable when I think about it now. I worked easily for over five years writing what I now know to be more or less procedural code in OO languages, but no one ever flagged it.</p>

<p>I actually think this is quite common in the industry. After working at some enterprise organisations and .NET consultancies, I worked as contractor in finance and ended up as a partner at a small Azure big data consultancy (both Azure and big data were in their infancy back then) before founding <a href="https://www.compositional-it.com/">Compositional IT</a> (CIT).</p>

<p>I started getting into F# when I started building a rules engine for an investment bank. We wrote it in C# but I realised afterwards that we had unknowingly been writing a composable functional pipeline in an OO language, creating one-method interfaces and chaining calls together using decorators and stuff. This was around 2010, so F# had just been included ‚Äúin the box‚Äù in Visual Studio 2010‚Äîso I started playing around with it as a hobby, partly because it looked interesting but also because I had grown frustrated with the amount of rigour and code needed in C# in order to ensure the quality of our software. I also started going to the London F# meetup which was a real eye opener: a different community with new ways of doing things in .NET. I also learned about open source‚Äîuntil then, I had no clue what GitHub was.</p>

<p>After I moved to the Azure consultancy, I started using F# more. Primarily, using it as a ‚Äúglue‚Äù language to do things like scripts and data analysis, but I realised after a while that it was just a really flexible general purpose language that let me get stuff done more quickly‚Äîso I started writing all sorts in it.</p>

<blockquote>
  <p>I was surprised. I had thought it was simply for maths or data scraping but found it equally adept at web applications or cloud services in Azure. Once I‚Äôd gotten over the initial hurdle of resisting the OO muscle memory and learned techniques to achieve the same goals that I knew in C#, it was completely fun and empowering‚Äîas if I had started programming again and learning something new and exciting.</p>
</blockquote>

<p>Just before I moved to Germany, I founded CIT‚Äîthe goal was simple: functional programming for everyday software. Not maths and science or big data, but line of business apps, database systems, ETL processes, and so on. We‚Äôve been going for over 4 years now. We provide training and coaching for teams looking to use F#, for consultancy and development services. We do all of our software development on .NET in F#, from full-stack web apps using <a href="https://safe-stack.github.io/">the SAFE Stack</a> to data transformation engines to cloud services.</p>

<h2 id="i-know-its-more-nuanced-than-this-but-if-you-could-sell-f-to-c-developers-in-a-sentence-or-two-how-would-you-do-it">I know it‚Äôs more nuanced than this: but if you could sell F# to C# developers in a sentence or two, how would you do it?</h2>

<p>F# really does bring the fun back into software development. You‚Äôll feel more productive, more confident and more empowered to deliver high-quality software for your customers.</p>

<h2 id="functional-programming-is-getting-a-lot-of-attention-in-the-c-world-as-the-language-is-adopting-much-of-its-concepts-especially-with-c-9-its-a-weird-balance-trying-to-have-functional-concepts-in-an-oo-language-how-do-you-feel-the-balance-is-going">Functional programming is getting a lot of attention in the C# world, as the language is adopting much of its concepts (especially with C# 9). It‚Äôs a weird balance: trying to have functional concepts in an OO language. How do you feel the balance is going?</h2>

<p>I have mixed opinions on this. On the one hand, for the C# dev it‚Äôs great‚Äîthey have a more powerful toolkit at their disposal. But I would hate to be a new developer starting in C# for the first time. There are so many ways to do things now, and the feature (and custom operator!) count is going through the roof. More than that, I worry that we‚Äôll end up with a kind of bifurcated C# ecosystem‚Äîthose that adopt the new features and those that won‚Äôt, and worse still: the risk of losing the identity of what C# really is.</p>

<p>I‚Äôm interested to see how it works out. Introducing things <a href="https://daveabrock.com/2020/07/06/c-sharp-9-deep-dive-records">like records</a> into C# is going to lead to some new and different design patterns being used that will have to naturally evolve over time.</p>

<h2 id="i-wont-ask-if-c-will-replace-fyouve-eloquently-written-about-why-the-answer-is-no-i-will-ask-you-this-though-is-there-a-dividing-line-of-when-you-should-use-c-oo-with-functional-concepts-or-straight-to-f">I won‚Äôt ask if C# will replace F#‚Äîyou‚Äôve eloquently written about why the answer is no. I will ask you this, though: is there a dividing line of when you should use C# (OO with functional concepts) or straight to F#?</h2>

<p>I‚Äôm not really sure the idea of ‚ÄúOO with functional concepts‚Äù really gels, to be honest. Some of the core ideas of FP‚Äîimmutability and expressions‚Äîare kind of the opposite of OO, which is all centered around mutable data structures, statements and side effects. By all means: use the features C# provides that come from the FP world and use them where it helps‚ÄîLINQ, higher order functions, pattern matching, immutable data structures‚Äîbut the more you try out those features to try what they can do without using OO constructs, the more you‚Äôll find C# pulls you ‚Äúback.‚Äù It‚Äôs a little like driving an Audi on the German motorway but never getting out of third gear.</p>

<blockquote>
  <p>My view is that 80% of the C# population today‚Äîmaybe more‚Äîwould be more productive and happier in F#. If you‚Äôre using LINQ, you favour composition over inheritance, and you‚Äôre excited by some of the new features in C# like records, switch expressions, tuples, and so on, F# will probably be a natural fit for you. All of those features are optimised as first-class citizens of the language, whilst things like mutability and classes are possible, but are somewhat atypical.</p>
</blockquote>

<p>This also feeds back to your other question‚ÄîI do fear that people will try these features out within the context of OO patterns, find them somehow limited, and leave thinking that FP isn‚Äôt worthwhile.</p>

<h2 id="lets-say-im-a-c-programmer-and-want-to-get-into-f-is-there-any-c-knowledge-that-will-help-me-understand-the-concepts-or-is-it-best-to-clear-my-mind-of-any-preconceived-notions-before-learning">Let‚Äôs say I‚Äôm a C# programmer and want to get into F#. Is there any C# knowledge that will help me understand the concepts, or is it best to clear my mind of any preconceived notions before learning?</h2>

<p>Probably the closest concept would be to imagine your whole program was a single LINQ query. Or, from a web app‚Äîimagine every controller method was a LINQ query. In reality it‚Äôs not like that, but that‚Äôs the closest I can think of. The fact that you‚Äôll know .NET inside and out is also a massive help. The things to forget are basically the OO and imperative parts of the language: classes, inheritance, mutable variables, while loops, and statements. You don‚Äôt really use any of those in everyday F# (and believe me, you don‚Äôt need any of them to write standard line of business apps).</p>

<h2 id="with-your-experience-bringing-people-and-organizations-on-to-f-what-have-teams-done-to-make-it-successful">With your experience bringing people and organizations on to F#, what have teams done to make it successful?</h2>

<p>I‚Äôm <a href="https://www.compositional-it.com/news-blog/tag/adopting-f-series">currently writing a series</a> right now on this very subject. In some ways, it‚Äôs no different to adopting any technology or tool. For example, ‚ÄúHow can I introduce unit testing in my team?‚Äù The blockers are very rarely technical‚Äîit‚Äôs nearly always organisational or process-related. The main tips I can give is to plan your adoption thoroughly and thoughtfully, and to show that you believe in F#. Don‚Äôt do it as a one person endeavour‚Äîhave at least two or three developers work on it. And ideally get a coach to help mentor your team as they start using F# to avoid common pitfalls.</p>

<blockquote>
  <p>Most people at the management level will support a team adopting any new technology as long as you can show the benefits of it and (importantly) address any concerns that individuals may have, and F# is no different in that regard. Ironically, I often see F# suggested to teams from the management level and not the other way around!</p>
</blockquote>

<p>Lastly, there are so many great learning resources available nowadays that simply weren‚Äôt available even 5 years ago, whether that‚Äôs paper, online courses, YouTube, Slack, and so on‚Äîwhilst .NET Core has F# built-in, so you don‚Äôt even need to install anything to start trying it out.</p>

<h2 id="as-an-oo-programmer-its-so-painful-always-having-to-worry-about-the-billion-dollar-mistake-nulls-we-cant-assume-anything-since-were-mutating-objects-all-over-the-place-and-often-throw-up-our-hands-and-do-null-checks-everywhere-although-the-language-has-improved-in-the-last-few-versions-how-does-f-handle-nulls-is-it-less-painful">As an OO programmer, it‚Äôs so painful always having to worry about ‚Äúthe billion dollar mistake‚Äù: nulls. We can‚Äôt assume anything since we‚Äôre mutating objects all over the place and often throw up our hands and do null checks everywhere (although the language has improved in the last few versions). How does F# handle nulls? Is it less painful?</h2>

<p>For F# types that you create, the language simply says: null isn‚Äôt allowed, and there‚Äôs no such thing as null. So in a sense, the problem goes away by simply removing it from the type system. Of course, you still have to handle business cases of ‚Äúabsence of a value,‚Äù so you create optional values‚Äîbasically a value that can either have something or nothing. The compiler won‚Äôt let you access the ‚Äúsomething‚Äù unless you first ‚Äúcheck‚Äù that the value isn‚Äôt nothing.</p>

<p>So, you spend more time upfront thinking about how you model your domain rather than simply saying that everything and anything is nullable. The good thing is, you totally lose that fear of ‚Äúcan this value be null when I dot into it‚Äù because it‚Äôs simply not part of the type system. It‚Äôs kind of like the flow analysis that C# 8 introduced for nullability checks‚Äîbut instead of flow analysis, it‚Äôs much simpler. It‚Äôs just a built-in type in the language. There‚Äôs nothing magical about it.</p>

<p>However, when it comes to interoperating with C# (and therefore the whole BCL), F# doesn‚Äôt have any special compiler support for null checks, so developers will often create a kind of ‚Äúanti-corruption‚Äù layer between the ‚Äúunsafe outside world‚Äù and the safe F# layer, which simply doesn‚Äôt have nulls. There‚Äôs also work going on to bring in support for the nullability surface in the BCL but I suspect that this will be in F# 6.</p>

<h2 id="f-and-functional-programming-in-general-emphasizes-purity-no-side-effects-does-f-enforce-this-or-is-it-just-designed-with-it-in-mind">F#, and functional programming in general, emphasizes purity: no side effects. Does F# enforce this, or is it just designed with it in mind?</h2>

<p>No, it doesn‚Äôt enforce it. There‚Äôs some parts of the language which make it obvious when you‚Äôre doing a side effect, but it‚Äôs nothing like what Haskell does. For starters, the CLR and BCL don‚Äôt have any notion of a side effect, so I think that this would difficult to introduce. It‚Äôs a good example of some of the design decisions that F# took when running on .NET‚Äîyou get all the goodness of .NET and the ecosystem, but some things like this would be challenging to do. In fact, F# has a lot of escape hatches like this. It strongly guides you down a certain path, but it usually has ways that you can do your own thing if you really need to.</p>

<p>You still can (and people do) write entire systems that are functionally pure, and the benefits of pure functions are certainly something that most F# folks are aware of (it‚Äôs much easier to reason about and test, for example). It just means that the language won‚Äôt force you to do it.</p>

<h2 id="do-you-feel-in-the-overall-net-community-that-f-gets-enough-attention-from-microsoft">Do you feel in the overall .NET community, that F# gets enough attention from Microsoft?</h2>

<p>I‚Äôd always love for there to be more F# coverage! If I think back to when I first started looking into F# though, it‚Äôs come a long way‚Äîthere‚Äôs more awareness of this language out there, especially from some of the bigger names in the .NET team. People are starting to realise that F# isn‚Äôt some crazy maths-and-science language, but it‚Äôs a general purpose language‚Äîit‚Äôs just that it takes a different approach towards how you organise your code. It still frustrates me to occasionally see people refer to use C# and .NET interchangeably, of course, but it‚Äôs getting better.</p>

<h2 id="what-is-your-one-piece-of-programming-advice">What is your one piece of programming advice?</h2>

<p>Great question. I think one thing I try to keep in mind is to avoid premature optimisation and design. Design systems for what you know is going to be needed, with extension points for what will most likely be required. You can never design for every eventuality, and you‚Äôll sometimes get it wrong, that‚Äôs life‚Äîoptimise for what is the most likely outcome.</p>
:ET